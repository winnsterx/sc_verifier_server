// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IECLocker {
    function controller() external view returns (address);
    function lockId() external view returns (uint256);
    function msgHash() external view returns (bytes32);
    function changeController(uint8 v, bytes32 r, bytes32 s, address newController) external;
    function open(uint8 v, bytes32 r, bytes32 s) external;
}

contract SignatureExploiter {
    address public immutable target;
    address public immutable attacker;
    
    constructor(address _target) {
        target = _target;
        attacker = msg.sender;
    }
    
    // The vulnerability is that the signature hash is computed incorrectly
    // It uses abi.encode([uint256(r), uint256(s), uint256(v)]) which creates a dynamic array
    // This will produce a completely different hash than expected
    function exploit() external {
        IECLocker locker = IECLocker(target);
        
        // Get the message hash
        bytes32 msgHash = locker.msgHash();
        
        // We need to find a valid signature for the current controller
        // But the hash computation is broken, so we might be able to bypass it
        
        // Let's try some edge cases
        // First, let's see what happens with v=0, r=0, s=0
        try locker.open(0, bytes32(0), bytes32(0)) {
            // If this works, great
        } catch {
            // Expected to fail
        }
        
        // The issue is that abi.encode([uint256(r), uint256(s), uint256(v)])
        // will encode a dynamic array, not just the values
        // This means the signature hash will be completely different
        
        // We need to find values that when encoded as an array produce a hash
        // that hasn't been used yet
        
        // Let's try to change the controller to our address
        // We need a valid signature from the current controller
        // But the hash check is broken, so we might be able to bypass it
    }
    
    // Try to find a collision or bypass the signature check
    function trySignature(uint8 v, bytes32 r, bytes32 s) external {
        IECLocker locker = IECLocker(target);
        
        // Try to change controller
        try locker.changeController(v, r, s, attacker) {
            // Success!
        } catch {
            // Failed
        }
    }
    
    // Helper to show how the broken hash is computed
    function computeBrokenHash(uint256 r, uint256 s, uint256 v) external pure returns (bytes32) {
        // This is what the contract does - it's wrong!
        return keccak256(abi.encode([r, s, v]));
    }
    
    // Show the correct way
    function computeCorrectHash(bytes32 r, bytes32 s, uint8 v) external pure returns (bytes32) {
        // This would be more correct
        return keccak256(abi.encodePacked(r, s, v));
    }
}