// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IImpersonator {
    function transferOwnership(address newOwner) external;
    function owner() external view returns (address);
}

interface Ownable {
    function transferOwnership(address newOwner) external;
}

contract ExploitCallback {
    address constant IMPERSONATOR = 0xa16E02E87b7454126E5E10d957A927A7F5B5d2be;
    address constant DEPLOYER = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;
    
    // What if we can trigger a callback from IMPERSONATOR to this contract
    // And during that callback, we call transferOwnership?
    
    // The Impersonator contract only has deployNewLock function
    // which deploys ECLocker contracts
    
    // ECLocker emits events but doesn't seem to callback
    
    // Wait... what if the trick is that we need to deploy this contract
    // at a specific address?
    
    // What if we need to deploy at address 0x42069d82D9592991704e6E41BF2589a76eAd1A91?
    // Then we'd be the controller of the existing lock!
    
    // That would require CREATE2 with specific salt...
    
    fallback() external {
        // If IMPERSONATOR calls us, transfer ownership
        if (msg.sender == IMPERSONATOR) {
            IImpersonator(IMPERSONATOR).transferOwnership(DEPLOYER);
        }
    }
    
    function transferOwnership(address newOwner) external {
        // Forward the call to IMPERSONATOR
        Ownable(IMPERSONATOR).transferOwnership(newOwner);
    }
}